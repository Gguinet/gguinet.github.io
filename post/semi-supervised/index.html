<!DOCTYPE html><html lang="en-us" >

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  
  
  <meta name="generator" content="Wowchemy 5.0.0-beta.1 for Hugo">
  

  

  
  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="Gauthier Guinet">

  
  
  
    
  
  <meta name="description" content="This blog post contains an introduction to Unsupervised Bilingual Alignment and Multilingual Alignment. We also go through the theoretical framework behind Learning to Rank and discuss how it might help produce better alignments in a Semi-Supervised fashion. We both hope that this post will serve as a good introduction to anyone interested in those topics.">

  
  <link rel="alternate" hreflang="en-us" href="https://gguinet.github.io/post/semi-supervised/">

  







  




  
  
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  

  
  
  
  <meta name="theme-color" content="#1565c0">
  

  
  

  
  
  
  
    
    
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css" integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha256-FMvZuGapsJLjouA6k7Eo2lusoAX9i0ShlWFG6qt7SLc=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous" media="print" onload="this.media='all'">

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/github.min.css" crossorigin="anonymous" title="hl-light" media="print" onload="this.media='all'">
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" media="print" onload="this.media='all'" disabled>
        
      
    

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.min.css" integrity="sha512-1xoFisiGdy9nvho8EgXuXvnpR5GAMSjFwp40gSRE3NwdUdIMIKuPa7bqoUhLD0O/5tPNhteAsE5XyyMi5reQVA==" crossorigin="anonymous" media="print" onload="this.media='all'">
    

    

    
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.2.2/lazysizes.min.js" integrity="sha512-TmDwFLhg3UA4ZG0Eb4MIyT1O1Mb+Oww5kFG0uHqXsdbyZz9DcvYQhKpGgNkamAI6h2lGGZq2X8ftOJvF/XjTUg==" crossorigin="anonymous" async></script>
      
    
      

      
      

      
    
      

      
      

      
    
      

      
      
        
      

      
    
      

      
      

      
    
      

      
      

      
    

  

  
  
  
    
      
      <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media="print" onload="this.media='all'">
    
  

  
  
  
  
  
  <link rel="stylesheet" href="/css/wowchemy.9d711cebf380679328885aff8188d64e.css">

  





<script async src="https://www.googletagmanager.com/gtag/js?id=UA-186920121-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];

  function gtag() {
      dataLayer.push(arguments);
  }

  function trackOutboundLink(url, target) {
    gtag('event', 'click', {
         'event_category': 'outbound',
         'event_label': url,
         'transport_type': 'beacon',
         'event_callback': function () {
           if (target !== '_blank') {
             document.location = url;
           }
         }
    });
    console.debug("Outbound link clicked: " + url);
  }

  function onClickCallback(event) {
    if ((event.target.tagName !== 'A') || (event.target.host === window.location.host)) {
      return;
    }
    trackOutboundLink(event.target, event.target.getAttribute('target'));  
  }

  gtag('js', new Date());
  gtag('config', 'UA-186920121-1', {});

  
  document.addEventListener('click', onClickCallback, false);
</script>


  

  


  
  

  

  
  <link rel="manifest" href="/index.webmanifest">
  

  <link rel="icon" type="image/png" href="/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_32x32_fill_lanczos_center_2.png">
  <link rel="apple-touch-icon" type="image/png" href="/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_192x192_fill_lanczos_center_2.png">

  <link rel="canonical" href="https://gguinet.github.io/post/semi-supervised/">

  
  
  
  
  
  
  
    
  
  
  <meta property="twitter:card" content="summary_large_image">
  
  <meta property="og:site_name" content="Gauthier Guinet">
  <meta property="og:url" content="https://gguinet.github.io/post/semi-supervised/">
  <meta property="og:title" content="From Learning to Rank to Unsupervised Translation: towards a deep learning archaeologist ? | Gauthier Guinet">
  <meta property="og:description" content="This blog post contains an introduction to Unsupervised Bilingual Alignment and Multilingual Alignment. We also go through the theoretical framework behind Learning to Rank and discuss how it might help produce better alignments in a Semi-Supervised fashion. We both hope that this post will serve as a good introduction to anyone interested in those topics."><meta property="og:image" content="https://gguinet.github.io/post/semi-supervised/featured.jpeg">
  <meta property="twitter:image" content="https://gguinet.github.io/post/semi-supervised/featured.jpeg"><meta property="og:locale" content="en-us">
  
    
      <meta property="article:published_time" content="2020-08-31T00:00:00&#43;00:00">
    
    <meta property="article:modified_time" content="2020-08-31T00:00:00&#43;00:00">
  

  


    






  




<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://gguinet.github.io/post/semi-supervised/"
  },
  "headline": "From Learning to Rank to Unsupervised Translation: towards a deep learning archaeologist ?",
  
  "image": [
    "https://gguinet.github.io/post/semi-supervised/featured.jpeg"
  ],
  
  "datePublished": "2020-08-31T00:00:00Z",
  "dateModified": "2020-08-31T00:00:00Z",
  
  "author": {
    "@type": "Person",
    "name": "Gauthier Guinet"
  },
  
  "publisher": {
    "@type": "Organization",
    "name": "Gauthier Guinet",
    "logo": {
      "@type": "ImageObject",
      "url": "https://gguinet.github.io/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_192x192_fill_lanczos_center_2.png"
    }
  },
  "description": "This blog post contains an introduction to Unsupervised Bilingual Alignment and Multilingual Alignment. We also go through the theoretical framework behind Learning to Rank and discuss how it might help produce better alignments in a Semi-Supervised fashion. We both hope that this post will serve as a good introduction to anyone interested in those topics."
}
</script>

  

  


  


  





  <title>From Learning to Rank to Unsupervised Translation: towards a deep learning archaeologist ? | Gauthier Guinet</title>

</head>


<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" class="page-wrapper  ">

  
  
  
  
  
  
  
  
  <script src="/js/wowchemy-init.min.7d92a95e871a711a5c03f82410d0fe5d.js"></script>

  

<aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#" aria-label="Close"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control"
        aria-label="Search...">
        
      </div>

      

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>



  <div class="page-header">
    












<nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
  <div class="container">

    
    <div class="d-none d-lg-inline-flex">
      <a class="navbar-brand" href="/">Gauthier Guinet</a>
    </div>
    

    
    <button type="button" class="navbar-toggler" data-toggle="collapse"
            data-target="#navbar-content" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
    <span><i class="fas fa-bars"></i></span>
    </button>
    

    
    <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
      <a class="navbar-brand" href="/">Gauthier Guinet</a>
    </div>
    

    
    
    <div class="navbar-collapse main-menu-item collapse justify-content-start" id="navbar-content">

      
      <ul class="navbar-nav d-md-inline-flex">
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
            
            
            
              
            
            
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#about"><span>Home</span></a>
        </li>

        
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
            
            
            
              
            
            
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#featured"><span>Publications</span></a>
        </li>

        
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
            
            
            
              
            
            
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#posts"><span>Posts</span></a>
        </li>

        
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
            
            
            
              
            
            
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#project"><span>Technical Report</span></a>
        </li>

        
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
            
            
            
              
            
            
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#contact"><span>Contact</span></a>
        </li>

        
        

      

        
      </ul>
    </div>

    <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">

      
      
        
      

      
      
      <li class="nav-item">
        <a class="nav-link js-search" href="#" aria-label="Search"><i class="fas fa-search" aria-hidden="true"></i></a>
      </li>
      

      
      

      

    </ul>

  </div>
</nav>


  </div>

  <div class="page-body">
    <article class="article">

  












  

  
  
  
<div class="article-container pt-3">
  <h1>From Learning to Rank to Unsupervised Translation: towards a deep learning archaeologist ?</h1>

  

  
    


<div class="article-metadata">

  
  
  
  
  <div>
    

  <span class="author-highlighted">
      Gauthier Guinet</span>, <span >
      Paul Garnier</span>
  </div>
  
  

  
  <span class="article-date">
    
    
      
    
    Aug 31, 2020
  </span>
  

  

  
  <span class="middot-divider"></span>
  <span class="article-reading-time">
    28 min read
  </span>
  

  
  
  
  
  

  
  

</div>

    













<div class="btn-links mb-3">
  
  








  






  
  
    
  
<a class="btn btn-outline-primary btn-page-header" href="https://github.com/Gguinet/semisupervised-alignment" target="_blank" rel="noopener">
  Code
</a>




  
  <a class="btn btn-outline-primary btn-page-header" href="/project/semi-supervised/">
    Project
  </a>
  











</div>


  
</div>



  <div class="article-container">

    <div class="article-style">
      <p>This blog post contains an introduction to Unsupervised Bilingual Alignment and Multilingual Alignment. We also go through the theoretical framework behind Learning to Rank and discuss how it might help produce better alignments in a Semi-Supervised fashion. This post was written with <a href="https://donsetpg.github.io" target="_blank" rel="noopener">Paul Garnier</a> and was initially supposed to explore the impact of learning to rank to Unsupervised Translation. We both hope that this post will serve as a good introduction to anyone interested in this topic.</p>
<style TYPE="text/css">
code.has-jax {font: inherit; font-size: 100%; background: inherit; border: inherit;}
</style>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'] // removed 'code' entry
    }
});
MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS_HTML-full"></script>
<h1 id="introduction">Introduction</h1>
<p align="center">
  <img width="" height="150" src="imgs/img_blog_1.png">
</p>
<br>
<center>
<em>
Example of the embedding of "Etudiant" in 6 dimensions.
</em>
</center>
<br/>
Word vectors are conceived to synthesize and quantify semantic nuances, using a few hundred coordinates. These are generally used in downstream tasks to improve generalization when the amount of data is scarce. The widespread use and successes of these "word embeddings" in monolingual tasks have inspired further research on the induction of multilingual word embeddings for two or more languages in the same vector space. 
<p align="center">
  <img width="" height="190" src="imgs/img_blog_2.png">
</p>
<br>
<center>
<em>
Words embeddings in 2 different languages but in the same vector space.
</em>
</center>
<br/>
The starting point was the discovery [[4]](https://papers.nips.cc/paper/5021-distributed-representations-of-words-and-phrases-and-their-compositionality.pdf) that word embedding spaces have similar structures across languages, even when considering distant language pairs like English and Vietnamese. More precisely, two sets of pre-trained vectors in different languages can be aligned to some extent: good word translations can be produced through a simple linear mapping between the two sets of embeddings. For example, learning a direct mapping between Italian and Portuguese leads to a word translation accuracy of 78.1% with a nearest neighbor (NN) criterion.
<p align="center">
  <img width="" height="190" src="imgs/img_blog_3.png">
</p>
<br>
<center>
<em>
Example of a direct mapping and translation with a NN criterion for French and English.
</em>
</center>
<br/>
Embeddings of translations and words with similar meaning are close (geometrically) in the shared  cross-lingual vector space. This property makes them very effective for cross-lingual Natural Language Processing (NLP) tasks.
The simplest way to evaluate the result is the Bilingual Lexicon Induction (BLI) criterion, which designs the dictionary's percentage that can be correctly induced. 
Thus, BLI is often the first step towards several downstream tasks such as Part-Of-Speech (POS) tagging, parsing, document classification, language genealogy analysis, or (unsupervised) machine translation.
<p>These common representations are frequently learned through a two-step process, whether in a bilingual or multilingual setting. First, monolingual word representations are learned over large portions of text; these pre-formed representations are actually available for several languages and are widely used, such as the Fasttext Wikipedia. Second, a correspondence between languages is learned in three ways: in a supervised manner, if parallel dictionaries or data are available to be used for supervisory purposes, with minimal supervision, for example, by using only identical strings, or in a completely unsupervised manner.</p>
<p>It is common practice in the literature on the subject to separate these two steps and not to address them simultaneously in a paper. Indeed, measuring the algorithm&rsquo;s efficiency would lose its meaning if the corpus of vectors is not identical at the beginning.</p>
<p>Concerning the second point, although three different approaches exist, they are broadly based on the same ideas: the goal is to identify a subset of points that are then used as anchors points to achieve alignment. In the supervised approach, these are the words for which the translation is available. In the semi-supervised approach, we will gradually try to enrich the small initial corpus to have more and more anchor points. The non-supervised approach differs because there is no parallel corpus or dictionary between the two languages. The subtlety of the algorithms will be to release a potential dictionary and then to enrich it progressively.</p>
<p>We will focus on this third approach. Although it is a less frequent scenario, it is of great interest for several reasons. First of all, from a theoretical point of view, it provides a practical answer to a fascinating problem of information theory: given a set of texts in a totally unknown language, what information can we retrieve? The algorithms we chose to implement contrast neatly with the classical approach used until now. Finally, for very distinct languages or languages that are no longer used, the common corpus can indeed be very thin.</p>
<p>Many developments have therefore taken place in recent years in this field of unsupervised bilingual lexicon induction. One of the recent discoveries is the idea that using information from other languages during the training process helps improve translating language pairs.</p>
<p>This discovery led us to formulate the problem as follows: <strong>is it possible to gain experience in the progressive learning of several languages?</strong> In other words, how can we make fair use of the learning of several acquired languages to learn a new one? This new formulation can lead one to consider the lexicon induction as a ranking problem.</p>
<p>We will proceed as follows:  First, we will outline state of the art and the different techniques used for unsupervised learning in this context. In particular, we will explain the Wasserstein Procrustes approach for bilingual and multi alignment. We then emphasize the lexicon induction given the alignment. We then present the Learning to Rank key concepts. We then discuss a method using learning to rank for lexicon induction, and then present some experimental results.</p>
<h1 id="unsupervised-bilingual-alignment">Unsupervised Bilingual Alignment</h1>
<p>This section provides a brief overview of unsupervised bilingual alignment methods to learn a mapping between two sets of embeddings. The majority are divided into two stages: the actual alignment and lexicon induction, given the alignment. Even if the lexicon induction is often taken into account when aligning (directly or indirectly, through the loss function), this distinction is useful from a theoretical perspective.</p>
<p align="center">
  <img width="" height="" src="imgs/alignement.png">
</p>
<br>
<center>
<em>
Word embeddings alignment (in dimension 2).
</em>
</center>
<br/>
Historically, the problem of word vector alignment has been formulated as as a quadratic problem.
This approach, resulting from the supervised literature, is then allowed to presume the absence of lexicon without modifying the framework. That is why we will deal with it first in what follows. 
<h2 id="orthogonal-procrustes-problem">Orthogonal Procrustes Problem</h2>
<p align="center">
  <img width="500" height="" src="imgs/img_blog_4.png">
</p>
<br>
<center>
<em>
Set of n words (embeddings of dimensions d) for 2 languages. 
</em>
</center>
<br/>
Procustes is a method that aligns points if given the correspondences between them (supervised scenario).
$\mathbf{X} \in \mathbb{R}^{n \times d}$ and $\mathbf{Y} \in \mathbb{R}^{n \times d}$ are the two sets of word embeddings or points and we suppose, as previously said, that we know which point **X** corresponds to which point **Y**. This leads us to solve the following least-square problem of optimization, looking for the **W** matrix performing the alignment [[5]](https://arxiv.org/pdf/1805.11222.pdf):
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Cmin+_%7B%5Cmathbf%7BW%7D+%5Cin+%5Cmathbb%7BR%7D%5E%7Bd+%5Ctimes+d%7D%7D%5C%7C%5Cmathbf%7BX%7D+%5Cmathbf%7BW%7D-%5Cmathbf%7BY%7D%5C%7C_%7B2%7D%5E%7B2%7D" />
</p>
<p align="center">
  <img width="" height="" src="imgs/gif_blog_1.gif">
</p>
<br>
<center>
<em>
Operation applied for each word in the first language. The goal is to minimize the distance between the orange and the blue vectors.
</em>
</center>
<br/>
We have access to a closed form solution with a cubic complexity. 
Restraining **W** to the set of orthogonal matrices $\mathcal{O}_{d}$, improves the alignments for two reasons: it limits overfitting by reducing the size of the minimization space and allows to translate the idea of keeping distances and angles, resulting from the similarity in the space structure. The resulting problem is known as Orthogonal Procrustes. It also admits a closed-form solution through a singular value decomposition (cubic complexity).
<p>Thus, if their correspondences are known, the translation matrix between two sets of points can be inferred without too many difficulties. The next step leading to unsupervised learning is to discover these point correspondences using Wasserstein distance.</p>
<h2 id="wasserstein-distance">Wasserstein Distance</h2>
<p>In a similar fashion, finding the correct mapping between two sets of word can be done by solving the following minimization problem:</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Cmin+_%7B%5Cmathbf%7BP%7D+%5Cin+%5Cmathcal%7BP%7D_%7Bn%7D%7D%5C%7C%5Cmathbf%7BX%7D-%5Cmathbf%7BP%7D+%5Cmathbf%7BY%7D%5C%7C_%7B2%7D%5E%7B2%7D" />
</p>
<p align="center">
  <img width="" height="" src="imgs/gif_blog_2.gif">
</p>
<p>$\mathcal{P}_{n}$ containing all the permutation matrices, the solution of the minimization, $P_t$ will be an alignment matrix giving away the pair of words. This 1 to 1 mapping can be achieved thanks to the Hungarian algorithm.
It is equivalent to solve the following linear program:</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Cmax+_%7B%5Cmathbf%7BP%7D+%5Cin+%5Cmathcal%7BP%7D_%7Bn%7D%7D+%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Ctop%7D+%5Cmathbf%7BP%7D+%5Cmathbf%7BY%7D%5Cright%29" />
</p>
<p>The combination of the Procustes- Wasserstein minimization problem is the following:</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Cmin+_%7B%5Cmathbf%7BQ%7D+%5Cin+%5Cmathcal%7BO%7D_%7Bd%7D%7D+%5Cmin+_%7B%5Cmathbf%7BP%7D+%5Cin+%5Cmathcal%7BP%7D_%7Bn%7D%7D%5C%7C%5Cmathbf%7BX+Q%7D-%5Cmathbf%7BP%7D+%5Cmathbf%7BY%7D%5C%7C_%7B2%7D%5E%7B2%7D" />
</p>
<p align="center">
  <img width="" height="" src="imgs/gif_blog_3.gif">
</p>
<p>To solve this problem, the approach of <a href="https://arxiv.org/pdf/1805.11222.pdf" target="_blank" rel="noopener">[5]</a> was to use a stochastic optimization algorithm.
As solving separately those 2 problems led to bad local optima, their choice was to select a smaller batch of size <em>b</em>, and perform their minimization algorithm on these sub-samples. The batch is playing the role of anchors points. Combining this with a convex relaxation for an optimal initialization, it leads to the following algorithm:</p>
<p align="center">
  <img width="" height="" src="imgs/algo_1.png">
</p>
<h2 id="other-unsupervised-approaches">Other unsupervised approaches</h2>
<p>Other approaches exist, but they are currently less efficient than the one described above for various reasons: complexity, efficiency&hellip; We will briefly describe the two main ones below.</p>
<p><strong>Optimal transport:</strong></p>
<p align="center">
  <img width="" height="190" src="imgs/img_blog_5.png">
</p>
<p>Optimal transport <a href="https://people.math.gatech.edu/~gangbo/Cedric-Villani.pdf" target="_blank" rel="noopener">[6]</a> formalizes the problem of finding a minimum cost mapping between two word embedding sets, viewed as discrete distributions. More precisely, they assume the following distributions:</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Cmu%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D+%5Cmathbf%7Bp%7D_%7Bi%7D+%5Cdelta_%7B%5Cmathbf%7Bx%7D%5E%7B%28i%29%7D%7D%2C+%5Cquad+%5Cnu%3D%5Csum_%7Bj%3D1%7D%5E%7Bm%7D+%5Cmathbf%7Bq%7D_%7Bj%7D+%5Cdelta_%7B%5Cmathbf%7By%7D%5E%7B%28i%29%7D%7D" />
</p>
<p>and look for a transportation map realizing:</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Cinf+_%7BT%7D%5Cleft%5C%7B%5Cint_%7B%5Cmathcal%7BX%7D%7D+c%28%5Cmathbf%7Bx%7D%2C+T%28%5Cmathbf%7Bx%7D%29%29+d+%5Cmu%28%5Cmathbf%7Bx%7D%29+%5C%3B+%5C%3B+%7C+%5C%3B+%5C%3B+T_%7B%5C%23%7D+%5Cmu%3D%5Cnu%5Cright%5C%7D" />
</p>
<p>where the cost $c(\mathbf{x}, T(\mathbf{x}))$ is typically just $| T(\mathbf{x}) - \mathbf{x} |$ and $T_{\sharp}
\mu = \nu$ implies that the source points must exactly map to the targets.</p>
<p align="center">
  <img width="300" height="300" src="imgs/img_blog_6.png">
</p>
<br>
<center>
<em>
Push forward operator
</em>
</center>
<br/>
Yet, this transportation not always exist and a relaxation is used. Thus, the discrete optimal transport (DOT) problem consists of finding a plan $\Gamma$ that solves
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Cmin+_%7B%5CGamma+%5Cin+%5CPi%28%5Cmathbf%7Bp%7D%2C+%5Cmathbf%7Bq%7D%29%7D%5Clangle%5CGamma%2C+%5Cmathbf%7BC%7D%5Crangle" />
</p>
<p>where $\mathbf{C} \in \mathbb{R}^{n \times m}$, e.g., $C_{i j}=\left|\mathbf{x}^{(i)}-\mathbf{y}^{(j)}\right|$ is the cost matrix and the total cost induced by $\Gamma$ is:</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Clangle%5CGamma%2C+C%5Crangle%3A%3D%5Csum_%7Bi+j%7D+%5CGamma_%7Bi+j%7D+C_%7Bi+j%7D+." />
</p>
<p>where $\Gamma$ belongs to the polytope:</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5CPi%28%5Cmathbf%7Bp%7D%2C+%5Cmathbf%7Bq%7D%29%3D%5Cleft%5C%7B%5CGamma+%5Cin+%5Cmathbb%7BR%7D_%7B%2B%7D%5E%7Bn+%5Ctimes+m%7D+%7C+%5CGamma+1_%7Bn%7D%3D%5Cmathbf%7Bp%7D%2C+%5CGamma%5E%7B%5Ctop%7D+1_%7Bn%7D%3D%5Cmathbf%7Bq%7D%5Cright%5C%7D" />
</p>
<p>A regularization is usually added, mostly through the form of an entropy penalization:</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Cmin+_%7B%5CGamma+%5Cin+%5CPi%28%5Cmathbf%7Bp%7D%2C+%5Cmathbf%7Bq%7D%29%7D%5Clangle%5CGamma%2C+%5Cmathbf%7BC%7D%5Crangle-%5Clambda+H%28%5CGamma%29" />
</p>
<p>Some works <a href="https://www.aclweb.org/anthology/D18-1214/" target="_blank" rel="noopener">[7]</a> are based on these observations and then propose algorithms, effective in our case, because they adapt to the particularities of word embeddings. However, we notice that even if the efficiency is higher, the complexity is redibitive and does not allow large vocabularies. Moreover, the research is more oriented towards improving the algorithm described above with optimal transport tools rather than towards a different path. This is why we will not focus in particular on this track. We should, however, note the use of Gromov-Wasserstein distance <a href="https://www.springer.com/gp/book/9780817645823" target="_blank" rel="noopener">[8]</a>, which allows calculating the distance between languages innovatively, although they are in distinct spaces, enabling to compare the metric spaces directly instead of samples across the spaces.</p>
<p><strong>Adversarial Training:</strong>
Another popular alternative approach derived from the literature on generative adversarial network <a href="https://arxiv.org/pdf/1406.2661.pdf" target="_blank" rel="noopener">[9]</a> is to align point clouds without cross-lingual supervision by training a discriminator and a generator <a href="https://arxiv.org/pdf/1710.04087.pdf" target="_blank" rel="noopener">[10]</a>. The discriminator aims at maximizing its ability to identify the origin of an embedding. The generator of <strong>W</strong> aims at preventing the discriminator from doing so by making <strong>WX</strong> and <strong>Y</strong> as similar as possible.</p>
<p align="center">
  <img width="" height="" src="imgs/gif_blog_4.gif">
</p>
<p>They note $\theta_{D}$ the discriminator parameters and consider the probability $P_{\theta_{D}}(\text { source }=1 | z)$ that a vector $z$ is the mapping of a source embedding (as opposed to a target embedding) according to the discriminator.
The discriminator loss can then be written as:</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Cbegin%7Baligned%7D%0A%5Cmathcal%7BL%7D_%7BD%7D%5Cleft%28%5Ctheta_%7BD%7D+%7C+W%5Cright%29%3D%0A%26-%5Cfrac%7B1%7D%7Bn%7D+%5Csum_%7Bi%3D1%7D%5E%7Bn%7D++%5Clog+P_%7B%5Ctheta_%7BD%7D%7D%5Cleft%28%5Ctext%7Bsource%7D%3D1+%7C+W+x_%7Bi%7D%5Cright%29++%5C%5C%0A%26-%5Cfrac%7B1%7D%7Bm%7D+%5Csum_%7Bi%3D1%7D%5E%7Bm%7D+%5Clog+P_%7B%5Ctheta_%7BD%7D%7D%5Cleft%28%5Ctext%7Bsource%7D%3D0+%7C+y_%7Bi%7D%5Cright%29%0A%5Cend%7Baligned%7D" />
</p>
<p>On the other hand, the loss of the generator is:</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Cbegin%7Baligned%7D%0A%5Cmathcal%7BL%7D_%7BW%7D%5Cleft%28W+%7C+%5Ctheta_%7BD%7D%5Cright%29%3D%0A-%26+%5Cfrac%7B1%7D%7Bn%7D+%5Csum_%7Bi%3D1%7D%5E%7Bn%7D+%5Clog+P_%7B%5Ctheta_%7BD%7D%7D%5Cleft%28%5Ctext%7Bsource%7D%3D0+%7C+W+x_%7Bi%7D%5Cright%29+%5C%5C%0A-%26+%5Cfrac%7B1%7D%7Bm%7D+%5Csum_%7Bi%3D1%7D%5E%7Bm%7D+%5Clog+P_%7B%5Ctheta_%7BD%7D%7D%5Cleft%28%5Ctext%7Bsource%7D%3D1+%7C+y_%7Bi%7D%5Cright%29%0A%5Cend%7Baligned%7D" />
</p>
<p>For every input sample, the discriminator and the mapping matrix $W$ are trained successively with stochastic gradient updates to minimize $\mathcal{L}_W$ and $\mathcal{L}_D$.</p>
<p>Yet, papers <a href="https://arxiv.org/pdf/1710.04087.pdf" target="_blank" rel="noopener">[10]</a> on the subject show that, although innovative, this framework is more useful as a pre-training for the classical model than as a full-fledged algorithm.</p>
<h2 id="multilingual-alignment">Multilingual alignment</h2>
<p>A natural way to improve the efficiency of these algorithms is to consider more than 2 languages.
Thus, when it comes to aligning multiple languages together, two principle approaches quickly come to mind and correspond to two optimization problems:</p>
<ul>
<li>Align all languages to one pivot language, often English, without considering the loss function other alignments. This leads to low complexity but also to low efficiency between the very distinct language, forced to transit through English.</li>
<li>Align all language pairs by putting them all in the loss function, without giving importance to any one in particular. If this improves the efficiency of the algorithm, the counterpart is in the complexity, which is very important because it is quadratic in the number of languages.</li>
</ul>
<p align="center">
  <img width="" height="" src="imgs/img_blog_7.png">
</p>
<br>
<center>
<em>
Example of both approaches to align multiple languages.
</em>
</center>
<br/>
<p>A trade-off must therefore be found between these two approaches.</p>
<p>Let us consider $\mathbf{X}_i$ word embeddings for each language $i$, $i=0$ can be considered as the reference language, $\mathbf{W}_i$ is the mapping matrix we want to learn and $\mathbf{P}_i$ the permutation matrix. The alignment of multiple languages using a reference language as pivot can be resumed by the following problem:</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Cmin+_%7B%5Cmathbf%7BW%7D_%7Bi%7D+%5Cin+%5Cmathcal%7BO%7D_%7Bd%7D%2C+%5Cmathbf%7BP%7D_%7Bi%7D+%5Cin+%5Cmathcal%7BP%7D_%7Bn%7D%7D+%5Csum_%7Bi%7D+%5Cell%5Cleft%28%5Cmathbf%7BX%7D_%7Bi%7D+%5Cmathbf%7BW%7D_%7Bi%7D%2C+%5Cmathbf%7BP%7D_%7Bi%7D+%5Cmathbf%7BX%7D_%7B0%7D%5Cright%29" />
</p>
<p>As said above, although this method gives satisfying results concerning the translations towards the reference language, it provides poor alignment for the secondary languages between themselves.</p>
<p>Therefore an interesting way of jointly aligning multiple languages to a common space has been brought through by Alaux et al. <a href="https://arxiv.org/pdf/1811.01124.pdf" target="_blank" rel="noopener">[11]</a>.</p>
<p>The idea is to consider each interaction between two given languages, therefore the previous sum becomes a double sum with two indexes <em>i</em> and <em>j</em>. To prevent the complexity from being to high and to keep track and control over the different translations, each translation between two languages is given a weight $\alpha_{i j}$:</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Cmin+_%7B%5Cmathbf%7BQ%7D_%7Bi%7D+%5Cin+%5Cmathcal%7BO%7D_%7Bd%7D%2C+%5Cmathbf%7BP%7D_%7Bi+j%7D+%5Cin+%5Cmathcal%7BP%7D_%7Bn%7D%7D+%5Csum_%7Bi%2C+j%7D+%5Calpha_%7Bi+j%7D+%5Cell%5Cleft%28%5Cmathbf%7BX%7D_%7Bi%7D+%5Cmathbf%7BQ%7D_%7Bi%7D%2C+%5Cmathbf%7BP%7D_%7Bi+j%7D+%5Cmathbf%7BX%7D_%7Bj%7D+%5Cmathbf%7BQ%7D_%7Bj%7D%5Cright%29" />
</p>
<p>The choice of these weights depends on the importance we want to give to the translation from language <em>i</em> to language <em>j</em>.</p>
<p>The previous knowledge we have on the similarities between two languages can come at hand here, for they will have a direct influence on the choice of the weight. However, choosing the appropriate weights can be uneasy. For instance, giving a high weight to a pair of close languages can be unnecessary, and doing the same for two distant languages can be a waste of computation. To effectively reach this minimization, they use an algorithm very similar to the stochastic optimization algorithm described above.</p>
<p>At the beginning, we wanted to use this algorithm to incorporate exogenous knowledge about languages to propose constants $\alpha_{i j}$ more relevant and leading to greater efficiency. Different techniques could result in these parameters: from the mathematical literature such as the Gromov-Wasserstein distance evoked above or from the linguistic literature, using the etymological tree of languages to approximate their degree of proximity or even from both. In the article implementing this algorithm, it is specified that the final $\alpha_{i j}$ is actually very simple: N if we consider a link to the pivot or 1 otherwise. Practical simulations have also led us to doubt the efficiency of this idea. This is why we decided to focus on the idea below that seemed more promising rather than on multialignments.</p>
<h1 id="word-translation-as-a-retrieval-task-post-alignment-lexicon-induction">Word translation as a retrieval task: Post-alignment Lexicon Induction</h1>
<p>The core idea of the least-square problem of optimization in Wasserstein Procrustes is to minimize the distance between a word and its translation. Hence, given the alignment, the inference part first consisted of finding the nearest neighbors (NN). Yet, this criterion had a major issue:
Nearest neighbors are by nature asymmetric: y being a K-NN of x does not imply that x is a K-NN of y. In high-dimensional spaces, this leads to a phenomenon that is detrimental to matching pairs based on a nearest neighbor rule: some vectors, called hubs, are with high probability nearest neighbors of many other points, while others (anti-hubs) are not nearest neighbors of any point. <a href="https://arxiv.org/abs/1412.6568" target="_blank" rel="noopener">[12]</a></p>
<p align="center">
  <img width="250" height="190" src="imgs/img_blog_8.png">
</p>
<p>Two solutions to this problem have been brought through new criteria, aiming to give similarity measure between two embeddings, thus matching them appropriately. Among them, the most popular is Cross-Domain Similarity Local Scaling (CSLS) <a href="https://arxiv.org/pdf/1710.04087.pdf" target="_blank" rel="noopener">[10]</a>. Others exist, such as Inverted Softmax (ISF)<a href="https://arxiv.org/pdf/1702.03859.pdf" target="_blank" rel="noopener">[13]</a>. Yet, they usually require to estimate noisy parameter in an unsupervised setting where we do not have a direct cross-validation criterion.</p>
<p>The idea behind CSLS is quite simple: it is a matter of calculating a cosine similarity between the two vectors, subtracting a penalty if one or both of the vectors is also similar at many other points.</p>
<p>More formally, we denote by $\mathcal{N}_{\mathrm{T}} (\mathbf{W} x_s)$ the neighboors of $\boldsymbol{x}_S$ for the target language, after the alignment (hence the presence of $\mathbf{W}$).</p>
<p>Similarly we denote by $\mathcal{N}_{\mathrm{S}}(y_t)$ the neighborhood associated with a word $t$ of the target language. The penalty term we consider is the mean similarity of a source embedding $x_s$ to its target neighborhood:</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+r_%7B%5Cmathrm%7BT%7D%7D%5Cleft%28W+x_%7Bs%7D%5Cright%29%3D%5Cfrac%7B1%7D%7BK%7D+%5Csum_%7By_%7Bt%7D+%5Cin+%5Cmathcal%7BN%7D_%7B%5Cmathrm%7BT%7D%7D%5Cleft%28W+x_%7Bs%7D%5Cright%29%7D+%5Ccos+%5Cleft%28W+x_%7Bs%7D%2C+y_%7Bt%7D%5Cright%29" />
</p>
<p>where cos(&hellip;) is the cosine similarity.</p>
<p align="center">
  <img width="" height="" src="imgs/gif_blog_5.gif">
</p>
<p>Likewise we denote by $r_{\mathrm{S}}\left(y_{t}\right)$ the mean similarity of a target word $y_{t}$ to its neighborhood. Finally, the CSLS is defined as:</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Coperatorname%7BCSLS%7D%5Cleft%28W+x_%7Bs%7D%2C+y_%7Bt%7D%5Cright%29%3D2+%5Ccos+%5Cleft%28W+x_%7Bs%7D%2C+y_%7Bt%7D%5Cright%29-r_%7B%5Cmathrm%7BT%7D%7D%5Cleft%28W+x_%7Bs%7D%5Cright%29-r_%7B%5Cmathrm%7BS%7D%7D%5Cleft%28y_%7Bt%7D%5Cright%29" />
</p>
<p>However, it may seem irrelevant to align the embedding words with the NN criterion metric and to use the CSLS criterion in the inference phase. Indeed, it creates a discrepancy between the learning of the translation model and the inference: the global minimum on the set of vectors of one does not necessarily correspond to one of the other. This naturally led to modify the least-square optimization problem to propose a loss function associated with CSLS.</p>
<p>By assuming that word vectors are $\ell_{2}-$ normalized, we have:</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Ccos+%5Cleft%28%5Cmathbf%7BW%7D+%5Cmathbf%7Bx%7D_%7Bi%7D%2C+%5Cmathbf%7By%7D_%7Bi%7D%5Cright%29%3D%5Cmathbf%7Bx%7D_%7Bi%7D%5E%7B%5Ctop%7D+%5Cmathbf%7BW%7D%5E%7B%5Ctop%7D+%5Cmathbf%7By%7D_%7Bi%7D+." />
</p>
<p>Similarly, we have:</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Cleft%5C%7C%5Cmathbf%7By%7D_%7Bj%7D-%5Cmathbf%7BW%7D+%5Cmathbf%7Bx%7D_%7Bi%7D%5Cright%5C%7C_%7B2%7D%5E%7B2%7D%3D2-2+%5Cmathbf%7Bx%7D_%7Bi%7D%5E%7B%5Ctop%7D+%5Cmathbf%7BW%7D%5E%7B%5Ctop%7D+%5Cmathbf%7By%7D_%7Bj%7D+." />
</p>
<p>Therefore, finding the $k$ nearest neighbors of $\mathbf{W} \mathbf{x}_i$ among the elements of $\mathbf{Y}$ is equivalent to finding the $k$ elements of $\mathbf{Y}$ which have the largest dot product with $\mathbf{W} \mathbf{x}_i$. This equivalent formulation is adopted because it leads to a convex formulation when relaxing the orthogonality constraint on $\mathbf{W}$. This optimization problem with the Relaxed CSLS loss (RCSLS) is written as:</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cdisplaystyle%5Cmin+_%7B%5Cmathbf%7BW%7D+%5Cin+%5Cmathcal%7BO%7D_%7Bd%7D%7D+%5Cfrac%7B1%7D%7Bn%7D+%5Cdisplaystyle%5Csum_%7Bi%3D1%7D%5E%7Bn%7D-2+%5Cmathbf%7Bx%7D_%7Bi%7D%5E%7B%5Ctop%7D+%5Cmathbf%7BW%7D%5E%7B%5Ctop%7D+%5Cmathbf%7By%7D_%7Bi%7D+%5C%5C%0A%5Cquad%2B%5Cfrac%7B1%7D%7Bk%7D+%5Cdisplaystyle%5Csum_%7B%5Cmathbf%7By%7D_%7Bj%7D+%5Cin+%5Cmathcal%7BN%7D_%7BY%7D%5Cleft%28%5Cmathbf%7BW%7D+%5Cmathbf%7Bx%7D_%7Bi%7D%5Cright%29%7D+%5Cmathbf%7Bx%7D_%7Bi%7D%5E%7B%5Ctop%7D+%5Cmathbf%7BW%7D%5E%7B%5Ctop%7D+%5Cmathbf%7By%7D_%7Bj%7D+%5C%5C%0A%2B%5Cfrac%7B1%7D%7Bk%7D+%5Cdisplaystyle%5Csum_%7B%5Cmathbf%7BW%7D+%5Cmathbf%7Bx%7D_%7Bj%7D+%5Cin+%5Cmathcal%7BN%7D_%7BX%7D%5Cleft%28%5Cmathbf%7By%7D_%7Bi%7D%5Cright%29%7D+%5Cmathbf%7Bx%7D_%7Bj%7D%5E%7B%5Ctop%7D+%5Cmathbf%7BW%7D%5E%7B%5Ctop%7D+%5Cmathbf%7By%7D_%7Bi%7D%0A%5Cend%7Barray%7D" />
</p>
<p>A convex relaxation can then be computed by considering the convex hull of $\mathcal{O}_d$, i.e., the unit ball of the spectral norm. The results of the papers <a href="https://arxiv.org/pdf/1710.04087.pdf" target="_blank" rel="noopener">[10]</a> point out that RCSLS outperforms state of the art by, on average, 3 to 4% in accuracy compared to benchmark. This shows the importance of using the same criterion during training and inference.</p>
<p>Such an improvement using a relatively simple deterministic function led us to wonder whether we could go even further in improving performance. More precisely, considering Word translation as a retrieval task, the framework implemented was that of a ranking problem. To find the right translation, it was essential to optimally rank potential candidates. This naturally led us to want to clearly define this ranking problem and use the state of the art research on raking to tackle it. In this framework, the use of simple deterministic criteria such as NN, CSLS, or ISF was a low-tech answer and left a large field of potential improvement to be explored.</p>
<p>However, we wanted to keep the unsupervised framework, hence the idea of training the learning to rank algorithms on the learning of the translation of a language pair, English-Spanish, for instance, assuming the existence of a dictionary. This would then allow us to apply the learning to rank algorithm for another language pair without a dictionary, English-Italian, for instance. Similarly to the case of CSLS, the criterion can be tested first at the end of the alignment carried out thanks to the Procrustes-Wasserstein method. Then, in a second step, it can be integrated directly through the loss function in the alignment step. The following will quickly present the learning to rank framework to understand our implementation in more detail.</p>
<h1 id="learning-to-rank">Learning to Rank</h1>
<p>A ranking problem is defined as the task of ordering a set of items to maximize the utility of the entire set. Such a question is widely studied in several domains, such as Information Retrieval or Natural Language Processing. For example, on any e-commerce website, when given a query &ldquo;iPhone black case&rdquo; and the list of available products, the return list should be ordered by the probability of getting purchased. One can start understanding why a ranking problem is different than a classification or a regression task. While their goal is to predict a class or a value, the ranking task needs to order an entire list, such that the higher you are, the more relevant you should be.</p>
<p align="center">
  <img width="400" height="300" src="imgs/img_blog_9.png">
</p>
<h2 id="theoretical-framework">Theoretical framework</h2>
<p>Let&rsquo;s start by diving into the theoretical framework of Learning to Rank. Let $\psi := { (X,Y) \in \mathcal{X}^n \times \mathbb{R}^{n}_{+}}$ be a training set, where:</p>
<ul>
<li>$X \in \mathcal{X}^n$ is a vector, also defined as $(x_1,&hellip;,x_n)$ where $x_i$ is an item.</li>
<li>$Y \in \mathbb{R}^{n}_{+}$ is a vector, also defined as $(y_1,&hellip;,y_n)$ where $y_i$ is a relevance labels.</li>
<li>$\mathcal{X}$ is the space of all items.</li>
</ul>
<p>Furthermore, we define an item $x \in \mathcal{X}$ as a query-documents pair $(q,d)$.</p>
<p>The goal is to find a scoring function $f : \mathcal{X}^n \rightarrow \mathbb{R}^{n}_{+}$ that would minimizes the following loss :</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Cmathcal%7BL%7D+%28f%29+%3A%3D+%5Cfrac%7B1%7D%7B%7C%5Cpsi%7C%7D+%5Cdisplaystyle%5Csum+_%7B%28X%2CY%29+%5Cin+%5Cpsi%7D+l%28Y%2Cf%28X%29%29" />
</p>
<p>where $l : (\mathbb{R}^{n}_{+})^2 \rightarrow \mathbb{R}$ is a local loss function.</p>
<p>One first et very important note is how $f$ is defined. This could be done in two ways:</p>
<ul>
<li>We consider $f$ as a <strong>univariate</strong> scoring function, meaning that it can be decomposed into a per-item scoring function with $u : x \mapsto \mathbb{R}_+$. We will have $f(X) = [u(x_0), \cdots , u(x_n)]$.</li>
<li>We consider $f$ as a <strong>multivariate</strong> scoring function, meaning that each item is scored relatively to every other item in the set, with $f$ in $\mathbb{R}^{n}_{+}$. This means that changing one item could change the score of the rest of the set.</li>
</ul>
<p>While the first option is simpler to implement, the second one is much closer to reality, as an item&rsquo;s relevance often depends on the distribution its in. For example, an article&rsquo;s relevance to an e-commerce query will always depend on what the website offers you next to it.</p>
<p>We now have to define some metrics in order to judge how good a ranking is. We start by defining the <em>Discounted Cumulativ Gain</em> (DCG) of a list:</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+++++DCG%40k%28%5Cpi%2CY%29+%3A%3D+%5Cdisplaystyle%5Csum+_%7Bj%3D1%7D+%5E+%7Bk%7D+%5Cfrac%7B2%5E%7By_j+%7D+-+1%7D%7Bln_%7B2%7D%281%2B%5Cpi%28j%29%29%7D" />
</p>
<p>where:</p>
<ul>
<li>$Y = (y_1,&hellip;,y_n)$ are the ground truth labels</li>
<li>$\pi(j)$ is the rank of the j-th item in X</li>
<li>$\frac{1}{ln_{2}(1+\pi(j))}$ is the discount factor</li>
<li>$k$ is how much we want to go deep into the list. A low value of $k$ means that we want to focus on how well ranked the start of our list is.</li>
</ul>
<p align="center">
  <img width="" height="300" src="imgs/img_blog_10.png">
</p>
<p>Most of the time however we want to compare this metric to the DCG obtained from the ground truth labels. We then define:</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+NDCG%40k%28%5Cpi%2CY%29+%3A%3D+%5Cfrac%7BDCG%40k%28%5Cpi%2CY%29%7D%7BDCG%40k%28%5Cpi%5E%2A%2CY%29%7D" />
</p>
<p>where $\pi^*$ is the item permutations induced by Y.</p>
<h2 id="loss-functions">Loss functions</h2>
<p>In</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Cmathcal%7BL%7D+%28f%29+%3A%3D+%5Cfrac%7B1%7D%7B%7C%5Cpsi%7C%7D+%5Cdisplaystyle%5Csum+_%7B%28X%2CY%29+%5Cin+%5Cpsi%7D+l%28Y%2Cf%28X%29%29" />
</p>
<p>we defined $l$ as a loss function between two ordered sets of items. One approach could be to use the metrics defined above, but as they are non-differentiable, this is not a feasible choice. Therefore, we have to develop some sort of surrogate loss function, differentiable, and with the same goal as our metric. Before diving into the possible approaches, one must define what <em>pointwise</em>, <em>pairwise</em>, and <em>listwise</em> loss functions are.</p>
<p>A pointwise loss will only compare one predicted label to the real one. Therefore, each item&rsquo;s label is not compared to any other piece of information.
A pairwise loss will compare 2 scores from 2 items at the same time. With the pairwise loss, a model will minimize the number of pairs in the wrong order relative to the proper labels.
A listwise loss can capture differences in scores throughout the entire list of items. While this is a more complex approach, it allows us to compare each score against the others.</p>
<p>Let&rsquo;s give an example for each sort of loss function, starting with a pointwise one. The sigmoid cross entropy for binary relevance labels can be defined as:</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+l%28Y%2C%5Chat+Y%29+%3D+%5Cdisplaystyle%5Csum+_%7Bj%3D1%7D%5E%7Bn%7Dy_j%5Clog%28p_j%29+%2B+%281-y_j%29%5Clog%281-p_j%29" />
</p>
<p>where $p_j = \frac{1}{1 + e^{-\hat y_j}}$ and $\hat Y$ is the predicted labels for each item from one model.</p>
<p>The pairwise logistic loss <a href="https://papers.nips.cc/paper/3708-ranking-measures-and-loss-functions-in-learning-to-rank.pdf" target="_blank" rel="noopener">[1]</a> is a pairwise loss function that compares if pair of items are ordered in the right order. We can define it as:</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+l%28Y%2C%5Chat+Y%29+%3D+%5Cdisplaystyle%5Csum+_%7Bj%3D1%7D%5E%7Bn%7D%5Cdisplaystyle%5Csum+_%7Bk%3D1%7D%5E%7Bn%7D+%5Cmathbb%7BI%7D_%7By_j+%3E+y_k%7D+%5Clog%281+%2B+e%5E%7B%5Chat+y_k+-+%5Chat+y_j%7D%29" />
</p>
<p>where $\mathbb{I}_{x}$ is the indicator function.</p>
<p>Finally, a listwise loss function like the Softmax cross-entropy <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-2007-40.pdf" target="_blank" rel="noopener">[2]</a> can be defined as:</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+l%28Y%2C%5Chat+Y%29+%3D+%5Cdisplaystyle%5Csum+_%7Bj%3D1%7D%5E%7Bn%7Dy_j+%5Clog%28%5Cfrac%7Be%5E%7B%5Chat+y_j%7D%7D%7B%5Csum+_%7Bk%3D1%7D%5E%7Bn%7De%5E%7B%5Chat+y_k%7D%7D%29" />
</p>
<p>All of these loss functions are surrogates that try to capture the goal of our metrics. Another approach would be to define a listwise loss function, as close as our metrics as possible. For example, one could try to build a differentiable version of the NDCG <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-2008-164.pdf" target="_blank" rel="noopener">[3]</a></p>
<h3 id="approxndcg-a-differentiable-ndcg">ApproxNDCG: a differentiable NDCG</h3>
<p>Let&rsquo;s take a query $q$, and define several useful functions:</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Cdelta+%3A+x+%5Cin+%5Cmathcal%7BX%7D+%5Cmapsto+%5Cdelta+%28x%29+%5Cin+%5C%7B0%2C1%5C%7D" />
</p>
<p>the relevance of an item $x$ regarding of the fixed query $q$, and</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Cpi+%3A+x+%5Cin+%5Cmathcal%7BX%7D+%5Cmapsto+%5Cpi+%28x%29+%5Cin+%5B1%2C+%5C%23%5Cmathcal%7BX%7D%5D" />
</p>
<p>the position of $x$ in the ranked list $\pi$ and finally, $\mathbb{I}_{{\pi(x) \leq k}}$ still represents the indicator function of the set ${\pi(x) \leq k}$. The idea is to use an differentiable approximation of the indicator function. One can show that we have the following approximation:</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Cmathbb%7BI%7D_%7B%5C%7B%5Cpi%28x%29+%5Cleq+k%5C%7D%7D+%5Capprox+%5Cfrac%7Be%5E%7B-%5Calpha+%28%5Cpi%28x%29+-+k%29%7D%7D%7B1+%2B+e%5E%7B-%5Calpha+%28%5Cpi%28x%29+-+k%29%7D%7D" />
</p>
<p>where $\alpha$ is a hyperparameter.</p>
<p><img src="imgs/example_approx_indicator.jpg" alt=""></p>
<center>
<em>
Example of approximation of the Indicator function for various values of alpha.
</em>
</center>
<br/>
<p>For a fixed query, we can re-define the DCG metric with the following equality :</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+DCG%40k%28%5Cpi%29+%3A%3D+%5Cdisplaystyle%5Csum+_%7Bx+%5Cin+%5Cmathcal%7BX%7D%7D+%5Cfrac%7B2%5E%7B%5Cdelta%28x%29%7D+-+1%7D%7Bln_%7B2%7D%281%2B%5Cpi%28x%29%29%7D+%5Cmathbb%7BI%7D_%7B%5C%7B%5Cpi%28x%29+%5Cleq+k%5C%7D%7D" />
</p>
<p>We now have to get an approximation of the $\pi$ function. The idea here is to get back to an indicator function since it is possible to compute them. We will be using the following equality :</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Cpi+%28x%29+%3D+1%2B+%5Cdisplaystyle%5Csum+_%7By+%5Cin+%5Cmathcal%7BX%7D%2F%5C%7Bx%5C%7D%7D+%5Cmathbb%7BI%7D_%7B%5C%7Bs_x+%5Cleq+s_y%5C%7D%7D" />
</p>
<p>where $s_x$ is defined as the score given to $x$ according to $f$, and define an approximation of $\pi$ with:</p>
<p align="center">
  <img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Chat%5Cpi%28x%29+%3D+1+%2B+%5Cdisplaystyle%5Csum+_%7By+%5Cin+%5Cmathcal%7BX%7D%2F%5C%7Bx%5C%7D%7D+%5Cfrac%7Be%5E%7B-%5Calpha+%28s_x+-+s_y%29%7D%7D%7B1+%2B+e%5E%7B-%5Calpha+%28s_x+-+s_y%29%7D%7D" />
</p>
<p>We can now define our differentiable version of the DCG metric by using these approximations.</p>
<h1 id="rubi-ranked-unsupervised-bilingual-induction">RUBI: Ranked Unsupervised Bilingual Induction</h1>
<p><strong>Motivations:</strong> Let&rsquo;s describe more precisely the functioning of our algorithm. Two points guided our approach:</p>
<ul>
<li>From a linguistic point of view, there is obviously a learning to learn phenomenon for languages. We observe that by assimilating the structure of the new language, its grammar, and vocabulary to one of the already known languages, it is easier for us to create links that help learning.
It is the search for these links that motivate us. We are convinced that they can be useful when inferring vocabulary.</li>
<li>Improvement induced by using the CSLS criterion suggests that there are complex geometrical phenomena (going beyond the existence as mentioned above of hubs) within the representations of languages, both ante, and post-alignment. Understanding these phenomena can lead to significantly increased efficiency.</li>
</ul>
<p><strong>Framework:</strong> Our goal is the same as for unsupervised bilingual alignment: we have a source language A and a target language B with no parallel data between the two. We want to derive an A-B dictionary, a classic BLI task. Our study&rsquo;s specificity is to assume that we also have a C language and an A-C dictionary at our disposal. To set up the learning to learn procedure, we proceed in 2 steps:</p>
<ul>
<li><strong>Learning:</strong> Using the Procrustes-Wasserstein algorithm, we align languages A and C in an unsupervised way. We then build a corpus of queries between the words from language A known from our dictionary and their potential translation into language C. Classical methods proposed the translation that maximized the NN or CSLS criteria. We use deep learning as part of our learning to rank framework to find a more complex criterion. One of the innovative features of our work is, therefore, to allow access to a much larger class of functions for the vocabulary induction stage. A sub-part of the dictionary is used for cross-validation. The way of rating the relevance of the potential translations, the inputs of the algorithm, the loss functions are all parameters that we studied and that are described in the next section.</li>
<li><strong>Prediction:</strong>  We thus have at the end of the training an algorithm taking as input a vocabulary word, in the form of an embedding and a list of potential translations. Our algorithm&rsquo;s output is the list sorted according to the learned criteria of these possible translations, the first word corresponding to the most probable translation, and so on. We first perform the alignment of languages A and B using the Procrustes-Wasserstein algorithm again. In a second step, thanks to the learning to rank, we perform the lexicon induction step.</li>
</ul>
<p>Finally, a final conceptual point is important to raise. In the context of the CSLS criterion, we have seen in the above that its use after alignment has improved. However, actually incorporating it in the alignment phase by modifying the loss function has allowed for greater consistency and a second improvement. However, these two changes were separated. Yet, the learning to rank framework is quite different. The main reason is the non-linearity resulting from deep-learning, unlike CSLS. Therefore, the global optimization is much more complex and does not allow relaxation to get back to a convex case. However, it is an area for improvement to be considered very seriously for future work.</p>
<h1 id="results">Results</h1>
<p>We can split our results into two very distinct parts. They both depend on how the Learning to Rank item sets are built. Given a word, you can build the list of potential traduction from a CSLS criterion and then force or not the right translation presence. This choice needs to be discussed thoroughly. First, let&rsquo;s quickly present some results with and without the correct prediction forced in the query.</p>
<h2 id="with-the-forced-prediction">With the forced prediction</h2>
<table>
<thead>
<tr>
<th>Method</th>
<th>EN-ES</th>
<th>ES-EN</th>
<th>EN-FR</th>
<th>FR-EN</th>
</tr>
</thead>
<tbody>
<tr>
<td>Wass. Proc. - NN</td>
<td>77.2</td>
<td>75.6</td>
<td>75.0</td>
<td>72.1</td>
</tr>
<tr>
<td>Wass. Proc. - CSLS</td>
<td>79.8</td>
<td>81.8</td>
<td>79.8</td>
<td>78.0</td>
</tr>
<tr>
<td>Wass. Proc. - ISF</td>
<td>80.2</td>
<td>80.3</td>
<td>79.6</td>
<td>77.2</td>
</tr>
<tr>
<td>Adv. - NN</td>
<td>69.8</td>
<td>71.3</td>
<td>70.4</td>
<td>61.9</td>
</tr>
<tr>
<td>Adv. -CSLS</td>
<td>75.7</td>
<td>79.7</td>
<td>77.8</td>
<td>71.2</td>
</tr>
<tr>
<td>RCSLS+spectral</td>
<td>83.5</td>
<td>85.7</td>
<td>82.3</td>
<td>84.1</td>
</tr>
<tr>
<td>RCSLS</td>
<td>84.1</td>
<td>86.3</td>
<td>83.3</td>
<td>84.1</td>
</tr>
<tr>
<td>RUBI</td>
<td><strong>93.3</strong> <em>(DE)</em></td>
<td><strong>91.6</strong> <em>(FR)</em></td>
<td><strong>93.8</strong> <em>(NL)</em></td>
<td><strong>91.9</strong> <em>(IT)</em></td>
</tr>
<tr>
<td></td>
<td><strong>EN-DE</strong></td>
<td><strong>DE-EN</strong></td>
<td><strong>EN-RU</strong></td>
<td><strong>RU-EN</strong></td>
</tr>
<tr>
<td>Wass. Proc. - NN</td>
<td>66.0</td>
<td>62.9</td>
<td>32.6</td>
<td>48.6</td>
</tr>
<tr>
<td>Wass. Proc. - CSLS</td>
<td>69.4</td>
<td>66.4</td>
<td>37.5</td>
<td>50.3</td>
</tr>
<tr>
<td>Wass. Proc. - ISF</td>
<td>66.9</td>
<td>64.2</td>
<td>36.9</td>
<td>50.3</td>
</tr>
<tr>
<td>Adv. - NN</td>
<td>63.1</td>
<td>59.6</td>
<td>29.1</td>
<td>41.5</td>
</tr>
<tr>
<td>Adv. -CSLS</td>
<td>70.1</td>
<td>66.4</td>
<td>37.2</td>
<td>48.1</td>
</tr>
<tr>
<td>RCSLS+spectral</td>
<td>78.2</td>
<td>75.8</td>
<td>56.1</td>
<td>66.5</td>
</tr>
<tr>
<td>RCSLS</td>
<td>79.1</td>
<td>76.3</td>
<td>57.9</td>
<td>67.2</td>
</tr>
<tr>
<td>RUBI</td>
<td><strong>93.6</strong> <em>(HU)</em></td>
<td><strong>89.8</strong> <em>(FR)</em></td>
<td><strong>83.7</strong> <em>(HU)</em></td>
<td>-</td>
</tr>
</tbody>
</table>
<p><img src="imgs/abl2.jpg" alt=""></p>
<p><strong>1: Loss function impact</strong> - Loss used for the Learning to Rank model. In other experiments, we found that ApproxNDCG and List MLE continue to perform similarly, hence our default choice of Approx NDCG.</p>
<p><strong>2: Group size impact</strong> - The group size measures how many items the Learning to Rank model takes as input simultaneously (multivariate vs. univariate). However, the dilemma is to optimize the computation time because increasing the group size exponentially increases the number of calculations.</p>
<p><strong>3: CSLS feature impact</strong> - The features for each potential translation in a query can incorporate several elements:</p>
<ul>
<li>the word embedding of the potential translation (size 300)</li>
<li>the word embedding of the query (size 300)</li>
<li>pre-computed features such as distance to query word in the aligned vector space, CSLS distance, ISF&hellip;</li>
</ul>
<p>Those features are crucial for learning as it will entirely rely on it.
At first, we decided to only use the word embedding of the potential translation and the query. That gave us a 600 feature list. However, after several experiments, we noticed that the learning to rank algorithm, despite the variation of the parameters, could not learn relevant information from these 600 features, the performance was poor. The function learned through deep learning was less efficient than a simple Euclidean distance between the potential translation and the query (NN criterion). In fact, after consulting the literature, we realized that using such a number of features is not very common. Most algorithms were only using pre-computed features (often less than a hundred). Although this information is already interesting in itself, we, therefore, turned to the second approach. We chose to restrict ourselves to certain well-specified types of pre-computed features to evaluate their full impact. More precisely, for a fixed k parameter, we provided as features the euclidean distance to the query and the CSLS(i) &ldquo;distance&rdquo; for i ranging from 1 to <em>k</em>. In other words, we provided information about the neighborhood through the penalties described in the section on CSLS.
Training with the full embeddings was also performed but did not lead to any improvements.</p>
<p><strong>4: Query size impact</strong> - Number of potential translations given with a query (number of items). There is a low incidence of the number of queries on the results, a very slight but perceptible decrease. Therefore, the algorithm is able, despite a large number of candidates, to discern the correct information.</p>
<p><img src="imgs/alb1.jpg" alt=""></p>
<p>Plot of the BLI criterion in the training step according to the CSLS criterion, i.e., the quality of the language&rsquo;s alignment for learning with English. The trend that emerges is that of a very clear positive correlation (linear trend plotted in red, (<strong>R</strong> ^2 = 0.82)). We have also shown the averages per language family (Romance, Germanic and Uralic). In conclusion, it seems easier to learn using a language that is well-aligned with English. Although this seems logical, it is not that obvious. Three clusters seem to appear in conjunction with the different families. Romance languages are associated with a high rate of alignment with English and, therefore, with high performance in the learning stage.
The Germanic language cluster has a lower performance combined with a slightly lower quality alignment. Knowing that English belongs to the Germanic language type, it is interesting to note this slight underperformance in alignment compared to Romance. Finally, the Slave cluster shows the worst performance in terms of alignment with English and, therefore, also the worst for the learning step.</p>
<h2 id="without-forced-prediction">Without forced prediction</h2>
<p><img src="imgs/abl3.jpg" alt=""></p>
<center>
<em>
Ablation study for the same pipeline as above, but without the right prediction forced into the query.
</em>
</center>
<br/>
<p>Without going into too many details, the same trends as above appear here and hold even when the proper translation is not artificially added to the query.</p>
<p>The main difference comes from the value of the BLI results: we only achieve the same results as the state of the art, or slightly better. We discuss in the conclusion the implication of these results, and especially the importance of forcing the right translation to appear in each query.</p>
<h1 id="conclusion">Conclusion</h1>
<p>If in the Learning to rank framework, a query without at least one relevant item doesn&rsquo;t have a lot of sense, this is not something one can ensure when working with unsupervised translation. If it is clear that given a query where the correct translation appears, a Learning to Rank model surpasses existing methods, it is still unclear on how to achieve such a query every time. While one way could be to extend the query size drastically, one still has to keep in mind the memory capability of such a model. Another bias might come from every query where the correct translation does not appear naturally (thus always giving poor results to every model except &ldquo;forced translation&rdquo; model).</p>
<p>We believe that leveraging the knowledge of previous idioms acquisition can keep leading to many improvements over existing models. This could be achieved thanks to Learning to Rank.</p>
<h1 id="references">References</h1>
<p>1: CHEN, WEI, YAN LIU, TIE, LAN, YANYAN, MING MA, ZHI &amp; LI, HANG 2009 Ranking measures and loss functions in learning to rank. In Advances in Neural Information Processing Systems 22 (ed. Y. Bengio, D. Schuurmans, J. D. Lafferty, C. K. I. Williams &amp; A. Culotta), pp. 315–323. Curran Associates, Inc</p>
<p>2: CAO, ZHE, QIN, TAO, LIU, TIE-YAN, TSAI, MING-FENG &amp; LI, HANG 2007 Learn- ing to rank: From pairwise approach to listwise approach. In Proceedings of the 24th International Conference on Machine Learning, pp. 129–136. New York, NY, USA: ACM.</p>
<p>3: QIN et al. A general approximation framework for direct optimization of information retrieval measures.</p>
<p>4: Ilya Sutskever, Thomas Mikolov, Kai Chen, Greg Corrado, Jeffrey Dean 2013. Distributed Representations of Words and Phrases and their Compositionality</p>
<p>5: Quentin Berthet, Edouard Grave and Armand Joulin: Unsupervised Alignment of Embeddings with Wasserstein Procrustes, 2018</p>
<p>6: Cédric Villani. Topics in optimal transportation. Number 58. American Mathematical Soc., 2003.</p>
<p>7: David Alvarez-Melis and Tommi Jaakkola. Gromov-wasserstein alignment of word embedding spaces. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, 2018.</p>
<p>8: Mikhail Gromov. Metric structures for Riemannian and non-Riemannian spaces. Springer Science &amp; Business Media, 2007.</p>
<p>9: Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair, Aaron Courville, and Yoshua Bengio. Generative adversarial nets. Advances in neural information processing systems, pp. 2672–2680, 2014.</p>
<p>10: Conneau, A., Lample, G., Ranzato, M., Denoyer, L., and Jégou, H: Word translation without parallel data, 2017</p>
<p>11: Jean Alaux, Edouard Grave, Marco Cuturi and Armand Joulin: Unsupervised hyperaligment for multilingual word embeddings, 2019</p>
<p>12: Georgiana Dinu, Angeliki Lazaridou, and Marco Baroni. Improving zero-shot learning by mitigating the hubness problem. International Conference on Learning Representations, Workshop Track, 2015.</p>
<p>13: Smith, S. L., Turban, D. H., Hamblin, S., and Hammerla, N. Y.: Bilingual word vectors,
orthogonal transformations and the inverted softmax., 2017</p>

    </div>

    








<div class="share-box" aria-hidden="true">
  <ul class="share">
    
      
      
      
        
      
      
      
      <li>
        <a href="https://twitter.com/intent/tweet?url=https://gguinet.github.io/post/semi-supervised/&amp;text=From%20Learning%20to%20Rank%20to%20Unsupervised%20Translation:%20towards%20a%20deep%20learning%20archaeologist%20?" target="_blank" rel="noopener" class="share-btn-twitter">
          <i class="fab fa-twitter"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.facebook.com/sharer.php?u=https://gguinet.github.io/post/semi-supervised/&amp;t=From%20Learning%20to%20Rank%20to%20Unsupervised%20Translation:%20towards%20a%20deep%20learning%20archaeologist%20?" target="_blank" rel="noopener" class="share-btn-facebook">
          <i class="fab fa-facebook"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="mailto:?subject=From%20Learning%20to%20Rank%20to%20Unsupervised%20Translation:%20towards%20a%20deep%20learning%20archaeologist%20?&amp;body=https://gguinet.github.io/post/semi-supervised/" target="_blank" rel="noopener" class="share-btn-email">
          <i class="fas fa-envelope"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.linkedin.com/shareArticle?url=https://gguinet.github.io/post/semi-supervised/&amp;title=From%20Learning%20to%20Rank%20to%20Unsupervised%20Translation:%20towards%20a%20deep%20learning%20archaeologist%20?" target="_blank" rel="noopener" class="share-btn-linkedin">
          <i class="fab fa-linkedin-in"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="whatsapp://send?text=From%20Learning%20to%20Rank%20to%20Unsupervised%20Translation:%20towards%20a%20deep%20learning%20archaeologist%20?%20https://gguinet.github.io/post/semi-supervised/" target="_blank" rel="noopener" class="share-btn-whatsapp">
          <i class="fab fa-whatsapp"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://service.weibo.com/share/share.php?url=https://gguinet.github.io/post/semi-supervised/&amp;title=From%20Learning%20to%20Rank%20to%20Unsupervised%20Translation:%20towards%20a%20deep%20learning%20archaeologist%20?" target="_blank" rel="noopener" class="share-btn-weibo">
          <i class="fab fa-weibo"></i>
        </a>
      </li>
    
  </ul>
</div>











  
  
    



  
  
  
    
  
  
  
  <div class="media author-card content-widget-hr">
    
      
      <a href="https://gguinet.github.io"><img class="avatar mr-3 avatar-circle" src="/authors/admin/avatar_hu4ff82f1a5fa81e94a77ee1876a858f6c_2359633_270x270_fill_q75_lanczos_center.jpg" alt="Gauthier Guinet"></a>
    

    <div class="media-body">
      <h5 class="card-title"><a href="https://gguinet.github.io">Gauthier Guinet</a></h5>
      <h6 class="card-subtitle">PhD Candidate</h6>
      <p class="card-text">I seek to explore how mathematical and computational techniques can help us understand, predict and ultimately improve human behavior in challenging situations.</p>
      <ul class="network-icon" aria-hidden="true">
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="/#contact" >
        <i class="fas fa-envelope"></i>
      </a>
    </li>
  
    
    
    
    
    
    
    
      
    
    <li>
      <a href="https://scholar.google.fr/citations?hl=fr&amp;user=zs13Hp0AAAAJ" target="_blank" rel="noopener">
        <i class="ai ai-google-scholar"></i>
      </a>
    </li>
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://github.com/Gguinet" target="_blank" rel="noopener">
        <i class="fab fa-github"></i>
      </a>
    </li>
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://linkedin.com/in/gauthier-guinet" target="_blank" rel="noopener">
        <i class="fab fa-linkedin"></i>
      </a>
    </li>
  
</ul>

    </div>
  </div>


  
    




  














  
  





  </div>
</article>
  </div>

  <div class="page-footer">
    
    
    <div class="container">
      <footer class="site-footer">
  

  <p class="powered-by">
    
  </p>

  
  






  <p class="powered-by">
    
    
    
    Published with
    <a href="https://wowchemy.com/?utm_campaign=poweredby" target="_blank" rel="noopener">Wowchemy</a>  —
    the free, <a href="https://github.com/wowchemy/wowchemy-hugo-modules" target="_blank" rel="noopener">
    open source</a> website builder that empowers creators.
    
  </p>
</footer>

    </div>
    
  </div>

  
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cite</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copy
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

      

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>

      
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      

      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/instant.page/5.1.0/instantpage.min.js" integrity="sha512-1+qUtKoh9XZW7j+6LhRMAyOrgSQKenQ4mluTR+cvxXjP1Z54RxZuzstR/H9kgPXQsVB8IW7DMDFUJpzLjvhGSQ==" crossorigin="anonymous"></script>

      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/highlight.min.js" integrity="sha512-TDKKr+IvoqZnPzc3l35hdjpHD0m+b2EC2SrLEgKDRWpxf2rFCxemkgvJ5kfU48ip+Y+m2XVKyOCD85ybtlZDmw==" crossorigin="anonymous"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/r.min.js"></script>
        
      

    

    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.min.js" integrity="sha512-SeiQaaDh73yrb56sTW/RgVdi/mMqNeM2oBwubFHagc5BkixSpP1fvqF47mKzPGWYSSy4RwbBunrJBQ4Co8fRWA==" crossorigin="anonymous"></script>
    

    
    
    <script>const code_highlighting = true;</script>
    

    
    
    
    
    
    
    <script>
      const search_config = {"indexURI":"/index.json","minLength":1,"threshold":0.3};
      const i18n = {"no_results":"No results found","placeholder":"Search...","results":"results found"};
      const content_type = {
        'post': "Posts",
        'project': "Projects",
        'publication' : "Publications",
        'event' : "Events",
        'slides' : "Slides"
        };
    </script>
    

    
    

    
    
    <script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
    

    
    

    
    
    

    
    

    
    

    
    
    
    
    
    
    
    
    
    
      
      
    
    
    <script src="/js/wowchemy.min.aeecf26c1eff6b9588dbafc1a9f3953c.js"></script>

    






</body>
</html>
